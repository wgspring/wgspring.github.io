<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wgspring</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wgspring.github.io/"/>
  <updated>2020-01-07T15:56:15.094Z</updated>
  <id>https://wgspring.github.io/</id>
  
  <author>
    <name>wgspring</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>socket实现不同程序间的通信</title>
    <link href="https://wgspring.github.io/socket/socket%E5%AE%9E%E7%8E%B0%E4%B8%8D%E5%90%8C%E7%A8%8B%E5%BA%8F%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/"/>
    <id>https://wgspring.github.io/socket/socket%E5%AE%9E%E7%8E%B0%E4%B8%8D%E5%90%8C%E7%A8%8B%E5%BA%8F%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/</id>
    <published>2020-01-04T23:14:49.096Z</published>
    <updated>2020-01-07T15:56:15.094Z</updated>
    
    <content type="html"><![CDATA[<p><ul class="markdownIt-TOC"><li><a href="#1-%E8%BF%9B%E7%A8%8B">1. 进程</a></li><li><a href="#2-tcp%E9%80%9A%E4%BF%A1%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B">2. TCP通信交互流程</a></li><li><a href="#3-c%E5%AE%9E%E7%8E%B0socket%E9%80%9A%E4%BF%A1">3. C++实现socket通信</a><ul><li><a href="#31-server%E5%AE%9E%E7%8E%B0">3.1. Server实现</a></li><li><a href="#32-client%E5%AE%9E%E7%8E%B0">3.2. Client实现</a></li><li><a href="#33-%E8%BF%90%E8%A1%8C%E6%95%88%E6%9E%9C">3.3. 运行效果</a></li></ul></li><li><a href="#4-c%E5%AE%9E%E7%8E%B0socket%E9%80%9A%E4%BF%A1">4. C#实现socket通信</a><ul><li><a href="#41-server%E5%AE%9E%E7%8E%B0">4.1. Server实现</a></li><li><a href="#42-client%E5%AE%9E%E7%8E%B0">4.2. client实现</a></li><li><a href="#43-%E8%BF%90%E8%A1%8C%E6%95%88%E6%9E%9C">4.3. 运行效果</a></li></ul></li><li><a href="#5-c%E5%92%8Cc%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1">5. C++和C#之间的通信</a></li></ul></p><h2 id="1-进程"><a class="markdownIt-Anchor" href="#1-进程"></a> 1. 进程</h2><p>当我们运行一个程序时，操作系统会为该程序启动一个进程来执行。比较直观的感受，可以通过打开Windows的任务管理器，或则Linux系统终端执行<code>top</code>查看进程。</p><p><img src="/img/socket%E5%AE%9E%E7%8E%B0%E4%B8%8D%E5%90%8C%E7%A8%8B%E5%BA%8F%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.png" alt="" /></p><p>每一个应用程序是一个独立的进程，拥有自己独立的资源，如果我们期望他们之间发生通信，则可以通过socket通信来实现。socket能够实现网络通信，也就是跨设备的应用间通信。例如计算机A上的QQ和计算机B上的QQ就是采用socket通信的。</p><h2 id="2-tcp通信交互流程"><a class="markdownIt-Anchor" href="#2-tcp通信交互流程"></a> 2. TCP通信交互流程</h2><p>说到网络通信，不得不提到计算机网络中的通信协议。关于TCP和UDP的区别不在本篇讨论范围之内。本文主要讲解通过socket使用TCP协议实现进程通信。下图展示了socket通信过程。</p><p><img src="/img/socket%E5%AE%9E%E7%8E%B0%E4%B8%8D%E5%90%8C%E7%A8%8B%E5%BA%8F%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/socket%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B.png" alt="" /></p><h2 id="3-c实现socket通信"><a class="markdownIt-Anchor" href="#3-c实现socket通信"></a> 3. C++实现socket通信</h2><h3 id="31-server实现"><a class="markdownIt-Anchor" href="#31-server实现"></a> 3.1. Server实现</h3><figure class="highlight cpp"><figcaption><span>Server.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 4096</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> server_socket, client_connect;</span><br><span class="line">    <span class="keyword">char</span> buff[MAXLINE];</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 创建socket</span></span><br><span class="line">    server_socket = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (server_socket == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"create socket failed! "</span> &lt;&lt; strerror(errno) &lt;&lt; <span class="string">"错误码："</span> &lt;&lt; errno &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 设置端口号为6666</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;address, <span class="number">0</span>, <span class="keyword">sizeof</span>(address)); <span class="comment">// 初始化servaddr所在内存为全0</span></span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_addr.s_addr = htonl(INADDR_ANY); <span class="comment">// 本机预使用的IP任意</span></span><br><span class="line">    address.sin_port = htons(<span class="number">6666</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 绑定端口号到socket上面</span></span><br><span class="line">    status = bind(server_socket, (struct sockaddr *)&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    <span class="keyword">if</span> (status == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"bind socket failed! "</span> &lt;&lt; strerror(errno) &lt;&lt; <span class="string">"错误码："</span> &lt;&lt; errno &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 监听端口号</span></span><br><span class="line">    status = listen(server_socket, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> (status == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"listen socket failed! "</span> &lt;&lt; strerror(errno) &lt;&lt; <span class="string">"错误码："</span> &lt;&lt; errno &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"======waiting for client's request======"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 接受客户端的连接请求</span></span><br><span class="line">    client_connect = accept(server_socket, (struct sockaddr *)<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (client_connect == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"accept socket failed! "</span> &lt;&lt; strerror(errno) &lt;&lt; <span class="string">"错误码："</span> &lt;&lt; errno &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"some one connected!!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 发送消息</span></span><br><span class="line">    <span class="keyword">char</span> sendline[] = <span class="string">"welcome!"</span>;</span><br><span class="line">    status = send(client_connect, sendline, <span class="built_in">strlen</span>(sendline), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (status &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"send msg failed! "</span> &lt;&lt; strerror(errno) &lt;&lt; <span class="string">"错误码："</span> &lt;&lt; errno &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 一直接收消息</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n = recv(client_connect, buff, MAXLINE, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="comment">//当信息长度为0，说明客户端连接断开</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        buff[n] = <span class="string">'\0'</span>; <span class="comment">// 设置文本终止符</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"recv msg from client: "</span> &lt;&lt; buff &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8. 关闭连接和服务器</span></span><br><span class="line">    close(client_connect);</span><br><span class="line">    close(server_socket);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="32-client实现"><a class="markdownIt-Anchor" href="#32-client实现"></a> 3.2. Client实现</h3><figure class="highlight cpp"><figcaption><span>Client.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 4096</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> client_socket;</span><br><span class="line">    <span class="keyword">char</span> buff[MAXLINE];</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 创建socket</span></span><br><span class="line">    client_socket = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (client_socket &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"create socket failed! "</span> &lt;&lt; strerror(errno) &lt;&lt; <span class="string">"错误码："</span> &lt;&lt; errno &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 设置端口号为6666</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;address, <span class="number">0</span>, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_port = htons(<span class="number">6666</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 设置访问ip</span></span><br><span class="line">    status = inet_pton(AF_INET, <span class="string">"127.0.0.1"</span>, &amp;address.sin_addr);</span><br><span class="line">    <span class="keyword">if</span> (status &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"inet_pton error! "</span> &lt;&lt; strerror(errno) &lt;&lt; <span class="string">"错误码："</span> &lt;&lt; errno &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 连接</span></span><br><span class="line">    status = connect(client_socket, (struct sockaddr *)&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    <span class="keyword">if</span> (status &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"connect failed! "</span> &lt;&lt; strerror(errno) &lt;&lt; <span class="string">"错误码："</span> &lt;&lt; errno &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 接收消息</span></span><br><span class="line">    <span class="keyword">int</span> n = recv(client_socket, buff, MAXLINE, <span class="number">0</span>);</span><br><span class="line">    buff[n] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"recv msg from Server: "</span> &lt;&lt; buff &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 一直发送消息</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Client: "</span>;</span><br><span class="line">        fgets(buff, MAXLINE, <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">string</span>(buff) == <span class="string">"quit\n"</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        status = send(client_socket, buff, <span class="built_in">strlen</span>(buff), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (status &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"send msg failed! "</span> &lt;&lt; strerror(errno) &lt;&lt; <span class="string">"错误码："</span> &lt;&lt; errno &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 关闭客户端</span></span><br><span class="line">    close(client_socket);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="33-运行效果"><a class="markdownIt-Anchor" href="#33-运行效果"></a> 3.3. 运行效果</h3><ol><li>编译：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ Server.cpp -o Server</span><br><span class="line">g++ Client.cpp -o Client</span><br></pre></td></tr></table></figure><ol start="2"><li>先运行Server，再另起终端运行Client：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./Server</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./Client</span><br></pre></td></tr></table></figure><ol start="3"><li>在Client上面发送信息</li></ol><p><img src="/img/socket%E5%AE%9E%E7%8E%B0%E4%B8%8D%E5%90%8C%E7%A8%8B%E5%BA%8F%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/C++%E8%BF%90%E8%A1%8C%E7%A4%BA%E4%BE%8B.png" alt="" /></p><h2 id="4-c实现socket通信"><a class="markdownIt-Anchor" href="#4-c实现socket通信"></a> 4. C#实现socket通信</h2><h3 id="41-server实现"><a class="markdownIt-Anchor" href="#41-server实现"></a> 4.1. Server实现</h3><figure class="highlight c#"><figcaption><span>Server.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Net;</span><br><span class="line"><span class="keyword">using</span> System.Net.Sockets;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">tcpserver</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">server</span></span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="meta">STAThread</span>]</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> max_length = <span class="number">4096</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[max_length]; <span class="comment">//用于缓存客户端所发送的信息,通过socket传递的信息必须为字节数组</span></span><br><span class="line">            <span class="comment">// 1. 建立socket</span></span><br><span class="line">            Socket server_socket = <span class="keyword">new</span> Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);</span><br><span class="line">            <span class="comment">// 2. 设置ip和端口</span></span><br><span class="line">            IPEndPoint ipep = <span class="keyword">new</span> IPEndPoint(IPAddress.Any, <span class="number">6666</span>);<span class="comment">//本机预使用的IP和端口</span></span><br><span class="line">            <span class="comment">// 3. 绑定端口</span></span><br><span class="line">            server_socket.Bind(ipep);<span class="comment">//绑定</span></span><br><span class="line">            <span class="comment">// 4. 监听端口</span></span><br><span class="line">            server_socket.Listen(<span class="number">10</span>);<span class="comment">//监听</span></span><br><span class="line">            Console.WriteLine(<span class="string">"waiting for a client"</span>);</span><br><span class="line">            <span class="comment">// 5. 接受客户端的连接请求</span></span><br><span class="line">            Socket client_connect = server_socket.Accept();<span class="comment">//当有可用的客户端连接尝试时执行，并返回一个新的socket,用于与客户端之间的通信</span></span><br><span class="line">            Console.WriteLine(<span class="string">"some one connected!!"</span>);</span><br><span class="line">            <span class="comment">// 6. 发送消息</span></span><br><span class="line">            <span class="keyword">string</span> welcome = <span class="string">"welcome here!"</span>;</span><br><span class="line">            data = Encoding.ASCII.GetBytes(welcome);   <span class="comment">// 字符串转字节数组</span></span><br><span class="line">            client_connect.Send(data, data.Length, SocketFlags.None);</span><br><span class="line">            <span class="comment">// 7. 一直接收消息</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> n = client_connect.Receive(data);</span><br><span class="line">                <span class="keyword">if</span> (n == <span class="number">0</span>)     <span class="comment">//当信息长度为0，说明客户端连接断开</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">string</span> s = Encoding.ASCII.GetString(data, <span class="number">0</span>, n); <span class="comment">// 字节数组转字符串</span></span><br><span class="line">                Console.WriteLine(<span class="string">"recv msg from client: "</span> + s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 8. 关闭连接和socket</span></span><br><span class="line">            client_connect.Close();</span><br><span class="line">            server_socket.Close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="42-client实现"><a class="markdownIt-Anchor" href="#42-client实现"></a> 4.2. client实现</h3><figure class="highlight c#"><figcaption><span>Client.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Net;</span><br><span class="line"><span class="keyword">using</span> System.Net.Sockets;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">tcpclient</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">client</span></span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="meta">STAThread</span>]</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> max_length = <span class="number">4096</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[max_length];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1. 创建socket</span></span><br><span class="line">            Socket client_socket = <span class="keyword">new</span> Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);</span><br><span class="line">            <span class="comment">// 2. 设置端口和设置需要访问的ip</span></span><br><span class="line">            IPEndPoint ie = <span class="keyword">new</span> IPEndPoint(IPAddress.Parse(<span class="string">"127.0.0.1"</span>), <span class="number">6666</span>);<span class="comment">//服务器的IP和端口</span></span><br><span class="line">            <span class="comment">// 3. 连接</span></span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//因为客户端只是用来向特定的服务器发送信息，所以不需要绑定本机的IP和端口。不需要监听。</span></span><br><span class="line">                client_socket.Connect(ie);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (SocketException e)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">"unable to connect to server"</span>);</span><br><span class="line">                Console.WriteLine(e.ToString());</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 4. 接收消息</span></span><br><span class="line">            <span class="keyword">int</span> n = client_socket.Receive(data);</span><br><span class="line">            <span class="keyword">string</span> stringdata = Encoding.ASCII.GetString(data, <span class="number">0</span>, n);</span><br><span class="line">            Console.WriteLine(<span class="string">"recv msg from Server: "</span> + stringdata);</span><br><span class="line">            <span class="comment">// 5. 一直发送消息</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.Write(<span class="string">"Client: "</span>);</span><br><span class="line">                <span class="keyword">string</span> input = Console.ReadLine();</span><br><span class="line">                <span class="keyword">if</span> (input == <span class="string">"quit"</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                data = Encoding.ASCII.GetBytes(input);     <span class="comment">// 字符串转字节数组</span></span><br><span class="line">                client_socket.Send(data, data.Length, SocketFlags.None);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 6. 关闭</span></span><br><span class="line">            client_socket.Shutdown(SocketShutdown.Both);</span><br><span class="line">            client_socket.Close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="43-运行效果"><a class="markdownIt-Anchor" href="#43-运行效果"></a> 4.3. 运行效果</h3><ol><li>编译：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mcs Server.cs</span><br><span class="line">mcs Client.cs</span><br></pre></td></tr></table></figure><ol start="2"><li>先运行Server，再另起终端运行Client：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mono Server.exe</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mono Client.exe</span><br></pre></td></tr></table></figure><ol start="3"><li>在Client上面发送信息</li></ol><p><img src="/img/socket%E5%AE%9E%E7%8E%B0%E4%B8%8D%E5%90%8C%E7%A8%8B%E5%BA%8F%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/C#%E8%BF%90%E8%A1%8C%E7%A4%BA%E4%BE%8B.png" alt="" /></p><h2 id="5-c和c之间的通信"><a class="markdownIt-Anchor" href="#5-c和c之间的通信"></a> 5. C++和C#之间的通信</h2><p>文章开篇介绍过，socket实现的是两进程之间的通信，没必要server和client都是同一个语言实现。只要server和client之间的通信协议一致就能够保证通信。前文介绍的都是基于TCP协议的，故无论server的语言和client的语言是否一致都可以通信。</p><p>下面演示使用c++版本的server和c#版本的client进行通信。</p><p><img src="/img/socket%E5%AE%9E%E7%8E%B0%E4%B8%8D%E5%90%8C%E7%A8%8B%E5%BA%8F%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/%E6%B7%B7%E5%90%88%E9%80%9A%E4%BF%A1%E7%A4%BA%E4%BE%8B.png" alt="" /></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;ul class=&quot;markdownIt-TOC&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#1-%E8%BF%9B%E7%A8%8B&quot;&gt;1. 进程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-tcp%E9%80%9A%E4%BF%A1%E4%BA%A4%E4%BA%92%E6
      
    
    </summary>
    
    
      <category term="socket" scheme="https://wgspring.github.io/categories/socket/"/>
    
    
      <category term="c++" scheme="https://wgspring.github.io/tags/c/"/>
    
      <category term="c#" scheme="https://wgspring.github.io/tags/c/"/>
    
      <category term="socket" scheme="https://wgspring.github.io/tags/socket/"/>
    
  </entry>
  
  <entry>
    <title>g++的使用</title>
    <link href="https://wgspring.github.io/g/g++%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://wgspring.github.io/g/g++%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2020-01-04T02:20:38.546Z</published>
    <updated>2020-01-05T07:31:34.236Z</updated>
    
    <content type="html"><![CDATA[<p><ul class="markdownIt-TOC"><li><a href="#1-%E7%94%9F%E6%88%90%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6">1. 生成可执行文件</a></li><li><a href="#2-%E7%94%9F%E6%88%90%E5%AF%B9%E8%B1%A1%E6%96%87%E4%BB%B6-o">2. 生成对象文件 – *.o</a><ul><li><a href="#21-%E5%AF%B9%E8%B1%A1%E6%96%87%E4%BB%B6%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6">2.1. 对象文件到可执行文件</a></li></ul></li><li><a href="#3-%E7%BC%96%E8%AF%91%E9%A2%84%E5%A4%84%E7%90%86">3. 编译预处理</a></li><li><a href="#4-%E7%94%9F%E6%88%90%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4">4. 生成汇编指令</a></li><li><a href="#5-%E7%94%9F%E6%88%90%E9%9D%99%E6%80%81%E5%BA%93">5. 生成静态库</a><ul><li><a href="#51-%E9%9D%99%E6%80%81%E5%BA%93%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6">5.1. 静态库到可执行文件</a></li></ul></li><li><a href="#6-%E7%94%9F%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93">6. 生成动态库</a><ul><li><a href="#61-%E5%8A%A8%E6%80%81%E5%BA%93%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6">6.1. 动态库到可执行文件</a></li><li><a href="#62-%E6%9F%A5%E7%9C%8B%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E9%93%BE%E6%8E%A5%E4%BA%86%E5%93%AA%E4%BA%9B%E5%BA%93">6.2. 查看可执行程序链接了哪些库</a></li></ul></li></ul></p><p>以下教程只适合<code>linux</code>系统</p><h2 id="1-生成可执行文件"><a class="markdownIt-Anchor" href="#1-生成可执行文件"></a> 1. 生成可执行文件</h2><p>当要求生成可执行文件时，要求代码里面一定要包含main函数，为程序入口。</p><ol><li><p>如果为单文件，例如<code>main.cpp</code>，执行：</p><ul><li><code>g++ main.cpp</code></li></ul><p>则会生成一个<code>a.out</code>文件，该文件即为可执行文件。终端执行<code>./a.out</code>即可</p></li><li><p>如果希望生成的文件名可以指定，则可以使用<code>-o</code>参数执行：</p><ul><li><code>g++ main.cpp -o main</code></li></ul><p>其中<code>main</code>即为你期望生成的文件名</p></li><li><p>如果为多个文件，可以使用<code>g++ *.cpp</code>来通配所有cpp文件</p></li></ol><h2 id="2-生成对象文件-o"><a class="markdownIt-Anchor" href="#2-生成对象文件-o"></a> 2. 生成对象文件 – *.o</h2><p>选项 -c 用来告诉编译器编译源代码但不要执行链接，输出结果为对象文件。文件默认名与源码文件名相同，只是将其后缀变为 .o。</p><p><code>g++ -c main.cpp</code></p><p>上述命令会生成<code>main.o</code></p><h3 id="21-对象文件到可执行文件"><a class="markdownIt-Anchor" href="#21-对象文件到可执行文件"></a> 2.1. 对象文件到可执行文件</h3><p>命令 g++ 能够直接识别 .o 文件并将其作为输入文件传递给链接器。</p><p><code>g++ main.o</code>或则<code>g++ main.o -o main</code></p><p>生成可执行文件<code>a.out</code>或则<code>main</code></p><h2 id="3-编译预处理"><a class="markdownIt-Anchor" href="#3-编译预处理"></a> 3. 编译预处理</h2><p>选项 -E 使 g++ 将源代码用编译预处理器处理后不再执行其他动作。</p><p><code>g++ -E main.cpp</code></p><p>上述命令不会生成文件，只会打印预处理的信息，如果要保存到文件可以附加使用<code>-o</code>选项</p><h2 id="4-生成汇编指令"><a class="markdownIt-Anchor" href="#4-生成汇编指令"></a> 4. 生成汇编指令</h2><p>选项 -S 指示编译器将程序编译成汇编语言，输出汇编语言代码而後结束。</p><p><code>g++ -S main.cpp</code></p><h2 id="5-生成静态库"><a class="markdownIt-Anchor" href="#5-生成静态库"></a> 5. 生成静态库</h2><p>静态库是编译器生成的一系列对象文件(<code>*.o文件</code>)的集合。链接一个程序时用库中的对象文件还是目录中的对象文件都是一样的。库中的成员包括普通函数，类定义，类的对象实例等等。静态库的另一个名字叫归档文件(archive)，管理这种归档文件的工具叫 ar 。</p><p><code>ar -r mylib.a object1.o object2.o</code></p><h3 id="51-静态库到可执行文件"><a class="markdownIt-Anchor" href="#51-静态库到可执行文件"></a> 5.1. 静态库到可执行文件</h3><p>命令 g++ 能够直接识别静态库 <code>.a</code> 文件并将其作为输入文件传递给链接器。</p><p><code>g++ mylib.a</code></p><h2 id="6-生成动态库"><a class="markdownIt-Anchor" href="#6-生成动态库"></a> 6. 生成动态库</h2><p><code>g++ one.cpp two.cpp three.cpp -fPIC -shared -o libtest.so</code></p><ul><li><p><code>-shared</code>：该选项指定生成动态连接库（让连接器生成T类型的导出符号表，有时候也生成弱连接W类型的导出符号），不用该标志外部程序无法连接。相当于一个可执行文件</p></li><li><p><code>-fPIC</code>：表示编译为位置独立的代码，不用此选项的话编译后的代码是位置相关的所以动态载入时是通过代码拷贝的方式来满足不同进程的需要，而不能达到真正代码段共享的目的。</p></li></ul><h3 id="61-动态库到可执行文件"><a class="markdownIt-Anchor" href="#61-动态库到可执行文件"></a> 6.1. 动态库到可执行文件</h3><p>例如讲<code>main.cpp</code>和动态库<code>libtest.so</code>一起链接</p><p><code>g++ main.cpp -L. -ltest -o main</code></p><ul><li><code>-L.</code>：表示要连接的库在当前目录中，<code>-L</code>指定动态库目录，<code>.</code>表示当前目录</li><li><code>-ltest</code>：编译器查找动态连接库时有隐含的命名规则，即在给出的名字前面加上lib，后面加上.so来确定库的名称。<code>-l</code>指定连接的动态库名称，<code>test</code>表示<code>libtest.so</code>这个文件。</li></ul><h3 id="62-查看可执行程序链接了哪些库"><a class="markdownIt-Anchor" href="#62-查看可执行程序链接了哪些库"></a> 6.2. 查看可执行程序链接了哪些库</h3><p><code>ldd main</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;ul class=&quot;markdownIt-TOC&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#1-%E7%94%9F%E6%88%90%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6&quot;&gt;1. 生成可执行文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a h
      
    
    </summary>
    
    
      <category term="g++" scheme="https://wgspring.github.io/categories/g/"/>
    
    
  </entry>
  
  <entry>
    <title>hexo书写文档插入代码块和引用</title>
    <link href="https://wgspring.github.io/hexo/%E6%8F%92%E4%BB%B6%E6%A0%87%E7%AD%BE/hexo%E4%B9%A6%E5%86%99%E6%96%87%E6%A1%A3%E6%8F%92%E5%85%A5%E4%BB%A3%E7%A0%81%E5%9D%97%E5%92%8C%E5%BC%95%E7%94%A8/"/>
    <id>https://wgspring.github.io/hexo/%E6%8F%92%E4%BB%B6%E6%A0%87%E7%AD%BE/hexo%E4%B9%A6%E5%86%99%E6%96%87%E6%A1%A3%E6%8F%92%E5%85%A5%E4%BB%A3%E7%A0%81%E5%9D%97%E5%92%8C%E5%BC%95%E7%94%A8/</id>
    <published>2019-12-31T14:50:55.000Z</published>
    <updated>2020-01-07T15:16:25.697Z</updated>
    
    <content type="html"><![CDATA[<p>使用hexo编写博客时，使用Markdown语法来插入代码、引用、图片时有时候并不起作用，推荐使用hexo标签插件来实现相同功能。</p><h2 id="插入代码块"><a class="markdownIt-Anchor" href="#插入代码块"></a> 插入代码块</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% codeblock [title] [lang:language] [option: value] %&#125;</span><br><span class="line">代码内容</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure><p><code>[..]</code>内为可选项。其中 <code>[option: value]</code>有以下选项:</p><table><thead><tr><th>Extra Options</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>line_number</code></td><td>Show line number</td><td><code>true</code></td></tr><tr><td><code>highlight</code></td><td>Enable code highlighting</td><td><code>true</code></td></tr><tr><td><code>first_line</code></td><td>Specify the first line number</td><td><code>1</code></td></tr><tr><td><code>mark</code></td><td>Line highlight specific line(s), each value separated by a comma. Specify number range using a dashExample: <code>mark:1,4-7,10</code> will mark line 1, 4 to 7 and 10.</td><td></td></tr><tr><td><code>wrap</code></td><td>Wrap the code block in <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/table" target="_blank" rel="noopener"><code>&lt;table&gt;</code></a></td><td><code>true</code></td></tr></tbody></table><h2 id="插入引用"><a class="markdownIt-Anchor" href="#插入引用"></a> 插入引用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% blockquote [author[, source]] %&#125;</span><br><span class="line">引用内容</span><br><span class="line">&#123;% endblockquote %&#125;</span><br></pre></td></tr></table></figure><p><code>[..]</code>内为可选项。</p><h2 id="插入图片和链接"><a class="markdownIt-Anchor" href="#插入图片和链接"></a> 插入图片和链接</h2><p>要想能够正确使用，需要将 <code>config.yml</code> 文件中的 <code>post_asset_folder</code> 选项设为 <code>true</code> 来打开。</p><figure class="highlight yml"><figcaption><span>_config.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><ul><li>插入路径 <code> {% asset_path 同名文件夹下的文件路径 %} </code></li><li>插入图片 <code> {% asset_img 同名文件夹下的文件路径 [title] %} </code></li><li>插入链接 <code> {% asset_link 同名文件夹下的文件路径 [title] %} </code></li></ul><h2 id="插入url链接"><a class="markdownIt-Anchor" href="#插入url链接"></a> 插入url链接</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% link title url %&#125;</span><br></pre></td></tr></table></figure><h2 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h2><p>另外还有一起其他不常用插件标签 <a href="https://hexo.io/zh-cn/docs/tag-plugins" title="" target="">传送门</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用hexo编写博客时，使用Markdown语法来插入代码、引用、图片时有时候并不起作用，推荐使用hexo标签插件来实现相同功能。&lt;/p&gt;
&lt;h2 id=&quot;插入代码块&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#插入代码块&quot;&gt;&lt;/a&gt; 插入代码
      
    
    </summary>
    
    
      <category term="hexo" scheme="https://wgspring.github.io/categories/hexo/"/>
    
      <category term="插件标签" scheme="https://wgspring.github.io/categories/hexo/%E6%8F%92%E4%BB%B6%E6%A0%87%E7%AD%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>hexo书写文档插入图片或链接</title>
    <link href="https://wgspring.github.io/hexo/%E6%8F%92%E4%BB%B6%E6%A0%87%E7%AD%BE/hexo%E4%B9%A6%E5%86%99%E6%96%87%E6%A1%A3%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E6%88%96%E9%93%BE%E6%8E%A5/"/>
    <id>https://wgspring.github.io/hexo/%E6%8F%92%E4%BB%B6%E6%A0%87%E7%AD%BE/hexo%E4%B9%A6%E5%86%99%E6%96%87%E6%A1%A3%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E6%88%96%E9%93%BE%E6%8E%A5/</id>
    <published>2019-12-29T13:18:03.000Z</published>
    <updated>2020-01-04T04:20:36.891Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开启文章资源文件夹"><a class="markdownIt-Anchor" href="#开启文章资源文件夹"></a> 开启文章资源文件夹</h2><p>对于那些想要更有规律地提供图片和其他资源以及想要将他们的资源分布在各个文章上的人来说，Hexo也提供了更组织化的方式来管理资源。这个稍微有些复杂但是管理资源非常方便的功能可以通过将 <code>config.yml</code> 文件中的 <code>post_asset_folder</code> 选项设为 <code>true</code> 来打开。</p><figure class="highlight yml"><figcaption><span>_config.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="插入资源"><a class="markdownIt-Anchor" href="#插入资源"></a> 插入资源</h2><p>当资源文件管理功能打开后，<code>Hexo</code>将会在你每一次通过 <code>hexo new [layout] &lt;title&gt;</code> 命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个文章文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们，这样你就得到了一个更简单而且方便得多的工作流。其中<code>[..]</code>内为可选项。</p><ul><li>插入路径 <code> {% asset_path 同名文件夹下的文件路径 %} </code></li><li>插入图片 <code> {% asset_img 同名文件夹下的文件路径 [title] %} </code></li><li>插入链接 <code> {% asset_link 同名文件夹下的文件路径 [title] %} </code></li></ul><p>比如说：当你打开文章资源文件夹功能后，你把一个 example.jpg 图片放在了你的资源文件夹中。然后插入</p><p><code>{% asset_img example.jpg This is an example image %}</code></p><p>通过这种方式，图片将会同时出现在文章和主页以及归档页中。</p><h2 id="备注"><a class="markdownIt-Anchor" href="#备注"></a> 备注</h2><p>如果插入的是url链接和图片，则规则和原Markdown规则一致。</p><ul><li>插入图片：<code>![title](url)</code></li><li>插入链接：<code>[title](url)</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;开启文章资源文件夹&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#开启文章资源文件夹&quot;&gt;&lt;/a&gt; 开启文章资源文件夹&lt;/h2&gt;
&lt;p&gt;对于那些想要更有规律地提供图片和其他资源以及想要将他们的资源分布在各个文章上的人来说，Hexo也提供了
      
    
    </summary>
    
    
      <category term="hexo" scheme="https://wgspring.github.io/categories/hexo/"/>
    
      <category term="插件标签" scheme="https://wgspring.github.io/categories/hexo/%E6%8F%92%E4%BB%B6%E6%A0%87%E7%AD%BE/"/>
    
    
  </entry>
  
</feed>
