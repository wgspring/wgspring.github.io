---
title: 锁
date: 2020-04-05T21:40:25+08:00
coverImage: https://s1.ax1x.com/2020/04/05/GruS78.jpg
categories: 
    - Java
    - 基础
tags: 
    - Java
    - 基础 
---
<!-- toc -->
本文主要讲解了众多锁的概念，包括：悲观锁、乐观锁、共享锁、独占锁、可重入锁和一些锁优化技术。

<!-- more -->

## 1. 悲观锁与乐观锁
### 1.1. 悲观锁
总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中`synchronized`和`ReentrantLock`等独占锁就是悲观锁思想的实现。

### 1.2. 乐观锁
总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，通过CAS(比较并交换)算法实现。**乐观锁适用于多读的应用类型**，这样可以提高吞吐量，像数据库提供的类似于`write_condition`机制，其实都是提供的乐观锁。如果是多写的场景，效率反而比悲观锁效率低。在Java中`java.util.concurrent.atomic`包下面的原子变量类就是使用了乐观锁实现的。

#### 1.2.1. ABA问题

如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？

很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 "ABA"问题。

这种问题可以通过版本号机制解决，只要数据修改，对应变量的版本号加一。


## 2. 共享锁和独占锁(排他锁)

### 2.1. 共享锁
共享锁，又称为读锁，获得共享锁之后，可以查看但无法修改和删除数据。共享锁可以理解为乐观锁，它放宽了加锁的条件，允许多线程同时访问该资源。例如 ReadWriteLock 读写锁允许同一时间内有多个线程进行读操作，它就属于共享锁。

### 2.2. 独占锁

独占锁，又称为写锁、排他锁。获准排他锁后，既能读数据，又能修改数据。独占锁可以理解为悲观锁，当每次访问资源时都要加上互斥锁，在任何时候最多只能有一个线程持有该锁。比如 synchronized 就是独占锁，

## 3. 可重入锁(递归锁)

可重入锁也叫递归锁，指的是**同一个线程**，如果外面的函数拥有此锁之后，内层的函数也可以继续获取该锁。在 Java 语言中 ReentrantLock 和 synchronized 都是可重入锁。

``` Java
public class LockExample {
    public static void main(String[] args) {
        reentrantA(); // 可重入锁
    }

    private synchronized static void reentrantA() {
        System.out.println(Thread.currentThread().getName() + "：执行 reentrantA");
        reentrantB();
    }

    private synchronized static void reentrantB() {
        System.out.println(Thread.currentThread().getName() + "：执行 reentrantB");
    }
}

// 如果不是可重入锁，reentrantA()调用reentrantB()时会阻塞。
```

## 4. JDK1.6锁优化

### 4.1. 自适应自旋锁

JDK 1.6 引入了自适应式自旋锁意味着自旋的时间不再是固定的时间了，比如在同一个锁对象上，如果通过自旋等待成功获取了锁，那么虚拟机就会认为，它下一次很有可能也会成功 (通过自旋获取到锁)，因此允许自旋等待的时间会相对的比较长，而当某个锁通过自旋很少成功获得过锁，那么以后在获取该锁时，可能会直接忽略掉自旋的过程，以避免浪费 CPU 的资源，这就是自适应自旋锁的功能。

### 4.2. 偏向锁

偏向锁是指在无竞争的情况下设置的一种锁状态。偏向锁的意思是它会偏向于第一个获取它的线程，当锁对象第一次被获取到之后，会在此对象头中设置标示为“01”，表示偏向锁的模式，并且在对象头中记录此线程的 ID，这种情况下，如果是持有偏向锁的线程每次在进入的话，不再进行任何同步操作，如 Locking、Unlocking 等，直到另一个线程尝试获取此锁的时候，偏向锁模式才会结束，偏向锁可以提高带有同步但无竞争的程序性能。但如果在多数锁总会被不同的线程访问时，偏向锁模式就比较多余了，此时可以通过 -XX:-UseBiasedLocking 来禁用偏向锁以提高性能。

### 4.3. 轻量锁

轻量锁是通过比较并交换（CAS，Compare and Swap）来实现的，它对比的是线程和对象的 Mark Word（对象头中的一个区域），如果更新成功则表示当前线程成功拥有此锁；如果失败，虚拟机会先检查对象的 Mark Word 是否指向当前线程的栈帧，如果是，则说明当前线程已经拥有此锁，否则，则说明此锁已经被其他线程占用了。当两个以上的线程争抢此锁时，轻量级锁就膨胀为重量级锁，这就是锁升级的过程，也是 JDK 1.6 锁优化的内容。

---

系列：
上一篇：{% post_link  %}
下一篇：{% post_link  %}
