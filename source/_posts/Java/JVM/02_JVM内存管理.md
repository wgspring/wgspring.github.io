---
title: 02_JVM内存管理
date: 2020-02-13T13:43:28+08:00
coverImage: https://i.loli.net/2020/02/13/CW61AzsY2BnLoa7.jpg
categories: 
    - Java
    - JVM
tags: 
    - Java
    - JVM
---
<!-- toc -->
本文主要讲解了 JVM 的内存划分以及栈上的执行过程。这块内容主要涉及以下这 3 个问题：
- JVM 是如何进行内存区域划分的？
- JVM 如何高效进行内存管理？
- 为什么需要有元空间，它又涉及什么问题？
<!-- more -->
为什么要问到 JVM 的内存区域划分呢？因为 Java 引以为豪的就是它的自动内存管理机制。相比于 C++的手动内存管理、复杂难以理解的指针等，Java 程序写起来就方便的多。

然而这种呼之即来挥之即去的内存申请和释放方式，自然也有它的代价。为了管理这些快速的内存申请释放操作，就必须引入一个池子来延迟这些内存区域的回收操作。

我们常说的内存回收，就是针对这个池子的操作。我们把上面说的这个池子，叫作堆，可以暂时把它看成一个整体。

## 1. JVM 内存布局

程序想要运行，就需要数据。有了数据，就需要在内存上存储。下图展示了JVM 的内存布局。值得一提的是Java 8 及之后的版本，彻底移除了持久代，而使用 Metaspace 来进行替代。这也表示着关于Perm的参数调优，已经没有了意义。

![](/img/Java/JVM/02_JVM%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86.png)

JVM 内存区域划分如图所示，从图中我们可以看出：
- JVM 堆中的数据是共享的，是占用内存最大的一块区域。
- 可以执行字节码的模块叫作执行引擎。
- 执行引擎在线程切换时怎么恢复？依靠的就是程序计数器。
- JVM 的内存划分与多线程是息息相关的。像我们程序中运行时用到的栈，以及本地方法栈，它们的维度都是线程。
- 本地内存包含元数据区和一些直接内存。

## 2. 虚拟机栈和本地方法栈

Java 虚拟机栈是基于线程的。哪怕你只有一个 main() 方法，也是以线程的方式运行的。在线程的生命周期中，参与计算的数据会频繁地入栈和出栈，栈的生命周期是和线程一样的。

栈里的每条数据，就是栈帧。在每个 Java 方法被调用的时候，都会创建一个栈帧，并入栈。一旦完成相应的调用，则出栈。所有的栈帧都出栈后，线程也就结束了。每个栈帧，都包含四个区域：

1. 局部变量表
2. 操作数栈
3. 动态连接
4. 返回地址

我们的应用程序，就是在不断操作这些内存空间中完成的。

本地方法栈是和虚拟机栈非常相似的一个区域，它服务的对象是 native 方法（本地方法，其他语言编写的方法）。你甚至可以认为虚拟机栈和本地方法栈是同一个区域，这并不影响我们对 JVM 的了解。

我们在栈帧的4个区域中发现还有一个操作数栈，可以看出这里有一个两层的栈。第一层是栈帧，对应着方法；第二层是方法的执行，对应着操作数。所有的字节码指令，其实都会抽象成对栈的入栈出栈操作。执行引擎只需要傻瓜式的按顺序执行，就可以保证它的正确性。

## 3. 程序计数器

那么我们设想一下，如果我们的程序在线程之间进行切换，凭什么能够知道这个线程已经执行到什么地方呢？

既然是线程，就代表它在获取 CPU 时间片上，是不可预知的，需要有一个地方，对线程正在运行的点位进行缓冲记录，以便在获取 CPU 时间片时能够快速恢复。

就好比你停下手中的工作，倒了杯茶，然后如何继续之前的工作？

程序计数器是一块较小的内存空间，它的作用可以看作是当前线程所执行的字节码的行号指示器。这里面存的，就是当前线程执行的进度。程序计数器也是因为线程而产生的，与虚拟机栈配合完成计算操作。程序计数器还存储了当前正在运行的流程，包括正在执行的指令、跳转、分支、循环、异常处理等。

我们可以看一下程序计数器里面的具体内容。下面这张图，就是使用 javap 命令输出的字节码。可以看到在每个 opcode 前面，都有一个序号。就是图中红框中的偏移地址，你可以认为它们就是程序计数器的内容。

![](/img/Java/JVM/02_JVM%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8.png)

## 4. 堆

堆是 JVM 上最大的内存区域，我们申请的几乎所有的对象，都是在这里存储的。我们常说的垃圾回收，操作的对象就是堆。

堆空间一般是程序启动时，就申请了，但是并不一定会全部使用。

随着对象的频繁创建，堆空间占用的越来越多，就需要不定期的对不再使用的对象进行回收。这个在 Java 中，就叫作 GC（Garbage Collection）。

由于对象的大小不一，在长时间运行后，堆空间会被许多细小的碎片占满，造成空间浪费。所以，仅仅销毁对象是不够的，还需要堆空间整理。这个过程非常的复杂，我会在后面的章节中介绍。

那一个对象创建的时候，到底是在堆上分配，还是在栈上分配呢？这和两个方面有关：对象的类型和在 Java 类中存在的位置。

Java 的对象可以分为基本数据类型和普通对象。

对于基本数据类型来说（byte、short、int、long、float、double、char)，有两种情况。

我们上面提到，每个线程拥有一个虚拟机栈。当你在方法体内声明了基本数据类型的对象，它就会在栈上直接分配。其他情况，都是在堆上分配。

对于普通对象来说，JVM 会首先在堆上创建对象，然后在其他地方使用的其实是它的引用。比如，把这个引用保存在虚拟机栈的局部变量表中。可以看到对象实际空间在堆上，对象的引用在栈上。

值得一提的是像 int[] 数组这样的内容，是在堆上分配的。数组并不是基本数据类型。

另外堆是所有线程共享的，如果是多个线程访问，会涉及数据同步问题，这个地方需要注意。

## 5. 元空间

有了栈、堆和程序计数器，似乎已经够用了，而在Java8之前的确是这样的。但是后来有一部分东西从堆上移出来了，也就是前文提到的Perm区。

回想一下类与对象的区别。对象是一个活生生的个体，可以参与到程序的运行中；类更像是一个模版，定义了一系列属性和操作。我们前面生成的 xx.class，就是放在 JVM 的元空间的，Java8之前在Perm区，属于堆上。

![](/img/Java/JVM/02_JVM%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%85%83%E7%A9%BA%E9%97%B4.png)

然后，元空间的好处也是它的坏处。使用非堆可以使用操作系统的内存，JVM 不会再出现方法区的内存溢出；但是，无限制的使用会造成操作系统的死亡。所以，一般也会使用参数 -XX:MaxMetaspaceSize 来控制大小。

另外在元空间中还有方法区，此文暂时不细说。现在，你只需要了解到，这个区域存储的内容，包括：类的信息、常量池、方法数据、方法代码。

另外需要注意这里说到常量池，JVM中存在多个常量池。字符串常量池以前在Perm中，现在依然在堆上。

## 6. 小结

- JVM 是如何进行内存区域划分的？
栈（虚拟机栈和本地方法栈）、堆、程序计数器、元空间（还包含方法区）、直接内存

- JVM 如何高效进行内存管理？
垃圾回收机制，对堆内存进行管理

- 为什么需要有元空间，它又涉及什么问题？
元空间旧身是Perm区在堆上，使用非堆可以使用操作系统的内存，JVM 不会再出现方法区的内存溢出。

---

JVM系列：
上一篇：{% post_link Java/JVM/01_为什么需要JVM？它处在什么位置？ %}
下一篇：{% post_link Java/JVM/03_JVM的类加载机制 %}