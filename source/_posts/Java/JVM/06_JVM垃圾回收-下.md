---
title: 06_JVM垃圾回收-下
date: 2020-02-17T20:22:06+08:00
coverImage: https://i.loli.net/2020/02/17/jfPYpVUlIr8EFmy.png
categories: 
    - Java
    - JVM
tags: 
    - Java
    - JVM
---
<!-- toc -->
本文将首先介绍几种非常重要的回收算法，然后着重介绍分代垃圾回收的内存划分和 GC 过程，最后介绍当前 JVM 中的几种常见垃圾回收器。这其中涉及到这些问题：

- JVM 中有哪些垃圾回收算法？它们各自有什么优劣？
- CMS 垃圾回收器是怎么工作的？有哪些阶段？
- 服务卡顿的元凶到底是谁？

<!-- more -->

按照语义上的意思，垃圾回收，首先就需要找到这些垃圾，然后回收掉。但是 GC 过程正好相反，它是先找到活跃的对象，然后把其他不活跃的对象判定为垃圾，然后删除。所以垃圾回收只与活跃的对象有关，和堆的大小无关。

## 1. 垃圾回收的阶段

### 1.1. 标记（Mark）

垃圾回收的第一步，就是找出活跃的对象。我们反复强调 GC 过程是逆向的。

我们在前面的文章谈到 GC Roots。根据 GC Roots 遍历所有的可达对象，这个过程，就叫作标记。

![](/img/Java/JVM/06_JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E4%B8%AD/%E6%A0%87%E8%AE%B0.png)

如图所示，圆圈代表的是对象。绿色的代表 GC Roots，红色的代表可以追溯到的对象。可以看到标记之后，仍然有多个灰色的圆圈，它们都是被回收的对象。

### 1.2. 清除（Sweep）

清除阶段就是把未被标记的对象回收掉。

![](/img/Java/JVM/06_JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E4%B8%AD/%E6%B8%85%E9%99%A4.png)

但是这种简单的清除方式，有一个明显的弊端，那就是碎片问题。回收后导致可用的内存很碎片化，很难再找到连续的大块空间。

### 1.3. 复制（Copy）

解决碎片问题没有银弹，有一个比较好的思路可以完成这个整理过程，就是提供一个对等的内存空间，将存活的对象复制过去，然后清除原内存空间。

![](/img/Java/JVM/06_JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E4%B8%AD/%E5%A4%8D%E5%88%B6.png)

这种方式看似非常完美的，解决了碎片问题。但是，它的弊端也非常明显。它浪费了几乎一半的内存空间来做这个事情，如果资源本来就很有限，这就是一种无法容忍的浪费。

### 1.4. 整理（Compact）

其实，不用分配一个对等的额外空间，也是可以完成内存的整理工作。

你可以把内存想象成一个非常大的数组，根据随机的 index 删除了一些数据。那么对整个数组的清理，其实是不需要另外一个数组来进行支持的，使用程序就可以实现。

它的主要思路，就是移动所有存活(未标记)的对象，且按照内存地址顺序依次排列，然后将末端内存地址以后的内存全部回收。

我们可以用一个理想的算法来看一下这个过程。

``` Java
last = 0
for(i=0;i<mems.length;i++){
  if(mems[i] != null){
      mems[last++] = mems[i]
      changeReference(mems[last])
  }
}
clear(mems,last,mems.length)
```

但是需要注意，这只是一个理想状态。对象的引用关系一般都是非常复杂的，我们这里不对具体的算法进行描述。你只需要了解，从效率上来说，一般整理算法是要低于复制算法的。

### 1.5. 常见的内存回收算法

**复制算法（Copy）**

复制算法是所有算法里面效率最高的，缺点是会造成一定的空间浪费。

**标记-清除（Mark-Sweep）**

效率一般，缺点是会造成内存碎片问题。

**标记-整理（Mark-Compact）**

效率比前两者要差，但没有空间浪费，也消除了内存碎片问题。

所以，没有最优的算法，只有最合适的算法。

## 2. 分代

JVM 是计算节点，而不是存储节点。最理想的情况，就是对象在用完之后，它的生命周期立马就结束了。而那些被频繁访问的资源，我们希望它能够常驻在内存里。

研究表明，大部分对象，可以分为两类：
- 大部分对象的生命周期都很短；-- 新生代
- 其他对象则很可能会存活很长时间。 -- 老年代

大部分死的快，其他的活的长。这个假设我们称之为**弱代假设**（weak generational hypothesis）。

现在的垃圾回收器，都会在物理上或者逻辑上，把这两类对象进行区分。我们把死的快的对象所占的区域，叫作年轻代（Young generation）。把其他活的长的对象所占的区域，叫作老年代（Old generation或Tenured Generation）。

### 2.1. 年轻代

年轻代使用的垃圾回收算法是复制算法。因为年轻代发生 GC 后，只会有非常少的对象存活，复制这部分对象是非常高效的。

我们前面也了解到复制算法会造成一定的空间浪费，所以年轻代中间也会分很多区域。

![](/img/Java/JVM/06_JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E4%B8%AD/%E5%B9%B4%E8%BD%BB%E4%BB%A3.png)

如图所示，年轻代分为：一个伊甸园空间（Eden ），两个幸存者空间（Survivor ）。

当年轻代中的 Eden 区分配满的时候，就会触发年轻代的 GC（Minor GC）。具体过程如下：

- 在 Eden 区执行了第一次 GC 之后，存活的对象会被复制到其中一个 Survivor 分区（以下简称from），清空Eden分区。
- Eden 区执行第二次 GC，将 Eden 和 from 区一起清理。存活的对象会被复制到 to 区；接下来，只需要清空 Eden分区 和 from 区就可以了。

所以在这个过程中，总会有一个 Survivor 分区是空置的。Eden、from、to 的默认比例是 8:1:1，所以只会造成 10% 的空间浪费。这个比例，是由参数 `-XX:SurvivorRatio` 进行配置的（默认为 8）。

另外在Eden中还有TLAB（Thread Local Allocation Buffer）。JVM 默认给每个线程开辟一个 buffer 区域，用来加速对象分配。这个 buffer 就放在 Eden 区中。

这个道理和 Java 语言中的 ThreadLocal 类似，避免了对公共区的操作，以及一些锁竞争。

![](/img/Java/JVM/06_JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E4%B8%AD/TLAB%E5%8C%BA.png)

对象的分配优先在 TLAB上 分配，但 TLAB 通常都很小，所以对象相对比较大的时候，会在 Eden 区的共享区域进行分配。

TLAB 是一种优化技术，类似的优化还有对象的栈上分配（这可以引出逃逸分析的话题，默认开启）。

### 2.2. 老年代

老年代一般使用“标记-清除”、“标记-整理”算法，因为老年代的对象存活率一般是比较高的，空间又比较大，拷贝起来并不划算，还不如采取就地收集的方式。

那么，对象是怎么进入老年代的呢？有多种途径。

**（1）提升（Promotion）**

每当发生一次 Minor GC，存活下来的对象年龄都会加 1。直到达到一定的阈值，就会把这些“老顽固”给提升到老年代。

这个阈值，可以通过参数 `‐XX:+MaxTenuringThreshold` 进行配置，最大值是 15。

**（2）分配担保**

前面提到年轻代GC时，每次存活的对象，都会放入其中一个幸存区，这个区域默认的比例是 10%。但是我们无法保证每次存活的对象都小于 10%，当 Survivor 空间不够时，这些对象也会直接在老年代上分配。

**（3）大对象直接在老年代分配**

超出某个大小的对象将直接在老年代分配。这个值是通过参数 `-XX:PretenureSizeThreshold` 进行配置的。默认为 0，意思是全部首选 Eden 区进行分配。

**（4）动态对象年龄判定**

有的垃圾回收算法，并不要求 age 必须达到 15 才能晋升到老年代，它会使用一些动态的计算方法。比如，从年龄最小的对象开始累加，如果累加的对象大小，大于幸存区的一半，则讲当前的对象age将作为新的阈值，年龄大于此阈值的对象直接进入老年代。

### 2.3. 卡片标记（card marking）

当没有卡片标记技术时，在做MinorGC时，为了找到年轻代中的存活对象，却不得不遍历整个老年代。如下图所示，如果我们只遍历年轻代找GC root，那么可以断定N, S, P, Q都是存活对象。但是，V却不会被认为是存活对象，其占据的内存就会被回收。反之Major GC时除了找GC root也要遍历整个年轻带。

![](/img/Java/JVM/06_JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E4%B8%AD/%E8%B7%A8%E4%BB%A3%E5%BC%95%E7%94%A8.png)

JVM采用了Card Marking(卡片标记)的方法，避免了在做Minor GC时需要对整个老年代扫描。具体的方法如下:

1. 将老年代的内存分片，1个片默认是512byte
2. 如果老年代的对象发生了修改，就把这个老年代对象所在的片标记为脏 dirty。或者老年代对象指向了新生代对象，那么它所在的片也会被标记为dirty
3. Minor GC扫描老年代空间时，只需要去扫描脏的卡片的对象，不需要扫描整个老年代空间。没有标记为脏的老年代片它没有指向新的新生代对象。

至于避免为了在做Major GC时需要对整个年轻代扫描，一般会选择在MajorGC之前进行一次MinorGC,使得年轻代对象尽量减少。

## 3. HotSpot 垃圾回收器

接下来介绍 HotSpot 的几个垃圾回收器，每种回收器都有各自的特点。我们在平常的 GC 优化时，一定要搞清楚现在用的是哪种垃圾回收器。

在此之前，我们把上面的分代垃圾回收整理成一张大图，在介绍下面的收集器时，你可以对应一下它们的位置。

![](/img/Java/JVM/06_JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E4%B8%AD/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%92%8C%E5%8C%BA%E5%9F%9F.png)

### 3.1. 年轻代垃圾回收器

#### 3.1.1. Serial 垃圾收集器

处理 GC 的只有一条线程，并且在垃圾回收的过程中暂停一切用户线程。

这可以说是最简单的垃圾回收器，但千万别以为它没有用武之地。因为简单，所以高效，它通常用在客户端应用上。因为客户端应用不会频繁创建很多对象，用户也不会感觉出明显的卡顿。相反，它使用的资源更少，也更轻量级。

#### 3.1.2. ParNew 垃圾收集器

ParNew 是 Serial 的多线程版本。由多条 GC 线程并行地进行垃圾清理。清理过程依然要停止用户线程。

ParNew 追求“低停顿时间”，与 Serial 唯一区别就是使用了多线程进行垃圾收集，在多 CPU 环境下性能比 Serial 会有一定程度的提升；但线程切换需要额外的开销，因此在单 CPU 环境中表现不如 Serial。

#### 3.1.3. Parallel Scavenge 垃圾收集器

另一个多线程版本的垃圾回收器。它与 ParNew 的主要区别是：

- Parallel Scavenge：追求 CPU 吞吐量，能够在较短时间内完成指定任务，适合没有交互的后台计算。弱交互强计算。
- ParNew：追求降低用户停顿时间，适合交互式应用。强交互弱计算。

### 3.2. 老年代垃圾收集器

#### 3.2.1. Serial Old 垃圾收集器

与年轻代的 Serial 垃圾收集器对应，都是单线程版本，同样适合客户端使用。

年轻代的 Serial，使用复制算法。

老年代的 Old Serial，使用标记-整理算法。

#### 3.2.2. Parallel Old

Parallel Old 收集器是 Parallel Scavenge 的老年代版本，追求 CPU 吞吐量。

#### 3.2.3. CMS 垃圾收集器

CMS（Concurrent Mark Sweep）收集器是以获取最短 GC 停顿时间为目标的收集器，它在垃圾收集时使得用户线程和 GC 线程能够并发执行，因此在垃圾收集过程中用户也不会感到明显的卡顿。我们会在后面的详细介绍它。

### 3.3. 配置参数

除了上面几个垃圾回收器，我们还有 G1、ZGC 等更加高级的垃圾回收器，它们都有专门的配置参数来使其生效。

通过 -XX:+PrintCommandLineFlags 参数，可以查看当前 Java 版本默认使用的垃圾回收器。

以下是一些配置参数：
- -XX:+UseSerialGC 年轻代和老年代都用串行收集器
- -XX:+UseParNewGC 年轻代使用 ParNew，老年代使用 Serial Old
- -XX:+UseParallelGC 年轻代使用 ParallerGC，老年代使用 Serial Old
- -XX:+UseParallelOldGC 新生代和老年代都使用并行收集器
- -XX:+UseConcMarkSweepGC，表示年轻代使用 ParNew，老年代的用 CMS
- -XX:+UseG1GC 使用 G1垃圾回收器
- -XX:+UseZGC 使用 ZGC 垃圾回收器

为了让你有个更好的印象，请看下图。它们的关系还是比较复杂的。尤其注意 -XX:+UseParNewGC 这个参数，已经在 Java9 中就被抛弃了。很多程序（比如 ES）会报这个错误，不要感到奇怪。

![](/img/Java/JVM/06_JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E4%B8%AD/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%8F%82%E6%95%B0.png)

线上使用最多的垃圾回收器，就有 CMS 和 G1，以及 Java8 默认的 Parallel Scavenge。
- CMS 的设置参数：-XX:+UseConcMarkSweepGC。
- Java8 的默认参数：-XX:+UseParallelGC。
- Java13 的默认参数：-XX:+UseG1GC。

## 4. STW

你有没有想过，如果在垃圾回收的时候（不管是标记还是整理复制），又有新的对象进入怎么办？

为了保证程序不会乱套，最好的办法就是暂停用户的一切线程。也就是在这段时间，你是不能 new 对象的，只能等待。表现在 JVM 上就是短暂的卡顿，什么都干不了。这个头疼的现象，就叫作 Stop the world。简称 STW。

标记阶段，大多数是要 STW 的。如果不暂停用户进程，在标记对象的时候，有可能有其他用户线程会产生一些新的对象和引用，造成混乱。

现在的垃圾回收器，都会尽量去减少这个过程。但即使是最先进的 ZGC，也会有短暂的 STW 过程。我们要做的就是在现有基础设施上，尽量减少 GC 停顿。

如果我们的 GC 非常的频繁，这种卡顿就会特别的明显，严重影响用户体验。

所以说虽然 Java 为我们提供了非常棒的自动内存管理机制，但也不能滥用，因为它是有 STW 硬伤的。

## 5. 小结

名词回顾：

**算法**

- Mark
- Sweep
- Copy
- Compact

**分代**

- Young generation
- Survivor
- Eden
- Old generation | Tenured Generation
- GC
    - Minor GC
    - Major GC

**名词**

- weak generational hypothesis
- 分配担保
- 提升
- 卡片标记
- STW


---

JVM系列：
上一篇：{% post_link Java/JVM/05_JVM垃圾回收-上 %}
下一篇：{% post_link Java/JVM/07_JVM垃圾回收器--CMS %}
