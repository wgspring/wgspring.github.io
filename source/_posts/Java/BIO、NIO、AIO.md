---
title: BIO、NIO、AIO
date: 2020-03-12T13:40:55+08:00
coverImage: https://s1.ax1x.com/2020/03/12/8ZsyuD.jpg
categories: 
    - Java
    - IO
tags: 
    - Java
    - IO
---
<!-- toc -->
Java处理IO有多种方式，说起BIO、NIO、AIO要从同步异步和阻塞非阻塞的概念说起。

<!-- more -->

## 1. 同步异步和阻塞非阻塞的概念

同步与异步：（多线程之间）
- 同步：线程A做完了，线程B开始做
- 异步：线程A和线程B同时做，A做完告知一声B

阻塞与非阻塞：（单线程内部）
- 阻塞：上一件事情做完才做下一件事情
- 非阻塞：上一件事情没做完也可以先做别的事情

举例：去图书馆借书
- 同步：和管理员说借书，管理员找到书之后再回家
- 异步：和管理说借书，然后直接回家干别的事。管理员找到书之后电话通知你，你再去拿。
- 阻塞：和管理员说借书，在拿到书之前一直处于懵逼状态
- 非阻塞：和管理员说借书，再拿到书之前玩玩手机并是不是抬头看看管理员拿好书没。

## 2. BIO--同步阻塞

以socket通信，Server接受消息，Client发送消息为例：

同步并阻塞，服务器的实现模式是**一个连接一个线程**，这样的模式很明显的一个缺陷是：由于客户端连接数与服务器线程数成正比关系，可能造成不必要的线程开销，严重的还将导致服务器内存溢出。当然，这种情况可以通过线程池机制改善，但并不能从本质上消除这个弊端。

最原始的socket通信是同步阻塞形式。Server和Client之间发送消息顺序是固定好的，Server接受，Client发送，在Client没发送完成之前，Client一直处于等待中（同步）。Client只有接收到消息才做下一件事情（阻塞）。


![](/img/Java/BIO%E3%80%81NIO%E3%80%81AIO/BIO.png)

## 3. NIO--同步非阻塞

为了解决阻塞问题和多线程开销问题。JDK1.4开始支持NIO--同步非阻塞IO，是一种多路复用技术。

服务器的实现模式是多个客户端请求对应服务器一个线程，即请求会注册到多路复用器Selector上，多路复用器轮询到连接**有IO请求时**才启动一个线程处理。

对于Server而言，对应的Client发送完信息才做后面的事情（同步）。但是一个Client没发送完，Server可以为其他Client服务，不会处于等待状态（非阻塞）。

![](/img/Java/BIO%E3%80%81NIO%E3%80%81AIO/NIO.png)

## 4. AIO--异步非阻塞

AIO是在JDK1.7之后引入的。是在NIO的基础上引入异步通道的概念，实现异步非阻塞式的IO处理。AIO不需要通过多路复用器对注册的通道进行轮询操作即可实现异步读写。

NIO采用轮询的方式，一直在轮询的询问stream中数据是否准备就绪，如果准备就绪发起处理。但是AIO就不需要了，AIO框架在windows下使用windows IOCP技术，在Linux下使用epoll多路复用IO技术模拟异步IO， 即：应用程序向操作系统注册IO监听，然后继续做自己的事情。操作系统发生IO事件，并且**准备好数据后**，在主动通知应用程序，触发相应的函数（这就是一种以订阅者模式进行的改造）。由于应用程序不是“轮询”方式而是订阅-通知方式，所以不再需要selector轮询，由channel通道直接到操作系统注册监听。

所以对于Server而言，Client没发送完之前，Server专心干自己的事情，Client发送完成会通知Server（异步）。Client没发送完，Server可以干自己的其他事情（非阻塞）。

![](/img/Java/BIO%E3%80%81NIO%E3%80%81AIO/AIO.png)

## 5. 总结

- BIO--同步并阻塞，一个连接对应一个线程。程序简单，但是线程开销大，适用较小的架构。
- NIO--同步非阻塞，一个请求对应一个线程。程序稍微复杂，使用连接数目多但时间短的架构。
- AIO--异步非阻塞，一个有效的请求对应一个线程。充分利用了操作系统参与并发，编程复杂，适合连接数目多且时间长的架构。


---

系列：
上一篇：{% post_link  %}
下一篇：{% post_link  %}
