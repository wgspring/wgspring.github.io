---
title: MySql的索引引擎
date: 2020-03-11T10:33:17+08:00
coverImage: https://s2.ax1x.com/2020/03/11/8kMWGT.jpg
categories: 
    - 数据库
    - MySQL
tags: 
    - 数据库
    - MySQL
---
<!-- toc -->
MySql是如何在庞大的数据库中高效率处理增删改查的呢？innoDB又是什么？

innoDB，是MySQL的数据库引擎之一，现为MySQL的默认存储引擎。innoDB能够高效存取主要依赖于索引，了解索引就要从B+树说起。

<!-- more -->
## 1. B+树

innoDB的整个索引就是一颗B+树，B+树是一个查找树。这里只简单回顾一下B+树的结构，具体B，B+，B*树的更多细节自行了解。

一个B+树示例：

![](/img/数据库/MySQL/MySql%E7%9A%84%E7%B4%A2%E5%BC%95%E5%BC%95%E6%93%8E/B+%E6%A0%91.png)

B+树特性：

1. 非叶子结点的子树指针与关键字个数相同；
2. 非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）；
3. 为所有叶子结点增加一个链指针；
4. 所有关键字都在叶子结点出现；

**注意：** innoDB采用的B+树，连接叶子节点之间的指针是双向的。上图中是单向的。

## 2. 主键索引/聚集索引

Mysql在创建一张表的时候，会自动根据主键建立一个索引。这个索引就叫主键索引。

B+树的叶子结点对应到innoDB中就是“页”。一页默认有16kb的数据。innoDB查找数据时，就会附带把目标所在的一整页数据都读取出来进行缓存。这么做的原因是因为**局部性原理**（某条数据被访问，附近的数据很可能也可能被访问）。

### 2.1. 页的结构--叶子节点

![](/img/数据库/MySQL/MySql%E7%9A%84%E7%B4%A2%E5%BC%95%E5%BC%95%E6%93%8E/%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9.png)


这里的“页”对应到B+树中就是叶子节点。用户数据就是叶子节点中的一个数据。这些用户数据是根据索引排序的，这里就是根据主键排序。相较B+树，页表里面还多了一个“目录”。目录相当于一个简单的二级索引，类比我们书籍的目录。目录项将众多用户数据进行了分组。

用户数据记录了完成信息，目录项只记录了索引信息和指针。

当innoDB查找数据时确认到某一个页之后，就会现在目录项中进行二分查找，确认最终数据所属分组，然后再在对应组内（用户数据区域）进行遍历。

当插入数据时，也是类似操作，插入时就保证了按索引排序的顺序。所以这就是为什么当我们查询`select * from table` 时结果是按照主键排序的原因。

### 2.2. 非叶子节点

当用户数据越来越多，页的数量也就越来越多，只通过Pre/Next指针来找页，效率就很低。这时就有了非叶子节点的结构。

![](/img/数据库/MySQL/MySql%E7%9A%84%E7%B4%A2%E5%BC%95%E5%BC%95%E6%93%8E/%E9%9D%9E%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9.png)



非叶子结点很简单，就是B+树的非叶子结点。记录了一个目录项和指向页的指针。这种非叶子结点是可以有很多层的。

![](/img/数据库/MySQL/MySql%E7%9A%84%E7%B4%A2%E5%BC%95%E5%BC%95%E6%93%8E/%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84.png)

从这里就可以看出就是一个完整的B+树了。当查找一个用户数据时，就会从根节点开始查找，然后向下层寻找。最终定位到一个页，然后页内查找。

## 3. 联合索引/辅助索引/二级索引

innoDB除了主键索引外，还有一种可以手动创建的索引叫做联合索引。

`create index my_index on table(b,c,d)`

上面的指令就是在表table上面以b,c,d这三个属性共同创建索引。排序规则是由b,c,d共同决定的，类似字典序排序，b的优先级最大。

联合索引也和主键索引一样是一颗B+树。主键索引中我们看到所有的用户数据都在叶子节点中，如果每创建一个联合索引，都再次记录所有用户数据，就会造成大量数据冗余，空间消耗巨大。所以联合索引和主键索引的一个区别就在“页”里面的的用户数据不一样。

主键索引的用户数据是完整的数据，联合索引和用户数据只包含索引项和主键。

当查找时，如果是联合索引查找的话，再定位到用户数据之后，会得到主键，然后根据主键再去主键索引中去获取完整数据。再次去主键索引中查找的这个过程叫做**回表**。

### 3.1. 查找规则

innoDB检索一条数据，有两种方法，一种是前面介绍的，从B+树的根节点开始寻找，这叫**索引查找**。如果不能利用索引进行查找，就只能**全盘扫描**了。全盘扫描会从主键索引的叶子节点的首结点开始，依次遍历这个链表，效率就会低很多。

能够利用主键索引查找的要求就是查找条件包含了主键。能够利用联合索引查找的条件就相对复杂一点点。

**最左前缀原则：** 触发联合索引的索引查找的前提条件是查找条件包含联合索引的第一个索引项。

举例子：

现有bcd索引。查找条件包含是b、bc、bcd、bd都是有可能触发索引查找的，c/cd就一定不会触发。

注意：这里是前提条件，是可能触发。也就是说当innoDB认为索引查找还不如全盘扫描快，就不会选择索引查找。

例如：

- `select * from table where b > 1`: 假如 `b > 1`的结果非常之多，这时候走联合索引还得进行很多次回表操作，不划算
- `select b from table where b > 1`: 此时用会走联合索引，因为只需要获取`b`,这在联合索引里面已经包含了`bcd+主键`的信息，不需要回表。同理b/bc/bcd/bd都是可行的，bcde就又需要回表。

### 3.2. 索引失效

1. 如果条件中有or，即使其中有条件带索引也不会使用。要想让索引生效，只能将or条件中的每个列都加上索引
    原因：or是满足其一，除非所有条件都有索引才能用索引。
2. 对于多列索引，不是使用的第一部分，则不会使用索引
    原因：最左前缀原则
3. like查询是以%开头
    原因：%模糊开头，在B+树中无法定位
4. 如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引
    原因：mysql默认数字和字符串比较时，会将字符串转成数字，不加引号就会看成数字。字段也就会转成数字，就需要修改整个索引，代价太大
5. 与数字一起运算的字段
    原因：例如`where a+1=3; `mysql认为没有a+1这个索引，优化：`where a=3-1;`
6. 如果mysql估计使用全表扫描要比使用索引快,则不使用索引
    原因：大量回表操作太费时

### 3.3. 覆盖索引

能通过检索索引就可以读取想要的数据，那就不需要回表操作了。如果一个索引包含了（或覆盖了）满足查询语句中字段与条件的数据就叫做**覆盖索引**。

当发起一个被索引覆盖的查询(也叫作索引覆盖查询)时，在EXPLAIN的Extra列可以看到“Using index”的信息。（在查询语句之前加上`explain `可以看到查询日志）

### 3.4. 索引条件下推

我们刚刚提到最左前缀原则。假设有一张table表,包含字段a、b、c、d、e,这些字段都是varchar类型。联合索引为(b,c,d)，然后我们执行下面的查询

``` sql
SELECT * FROM table
  WHERE b='aaa'
  AND c LIKE '%hello%'
  AND e LIKE '%world%';
```

这时候真正起作用的索引条件只有`b='aaa'`,当关闭索引条件下推时，查询路径是：先去联合索引中找`b='aaa'`,然后获取主键，回表获取所有字段，然后比较c和e的那个条件是否满足。

我们发现其实c字段是存在我们的联合索引中的，难道不可以利用一波吗？innoDB是考虑到这种优化的。

当**启用索引条件下推**时，查询路径是：先去联合索引中找`b='aaa'`,然后查询的结果检测是否满足`c LIKE '%hello%'`，不满足就直接下一条语句了，满足才获取主键，回表获取所有字段，然后比较`e LIKE '%world%'`是否满足。

当发起一个索引条件下推的查询时，在EXPLAIN的Extra列可以看到“Using index condition” 的信息。

注意：索引下推是避免回表操作，在主键索引中是没有意义的。

索引条件下推 默认开启：

```sql
SET optimizer_switch = 'index_condition_pushdown=off';
SET optimizer_switch = 'index_condition_pushdown=on';
```


---

系列：
上一篇：{% post_link  %}
下一篇：{% post_link  %}
